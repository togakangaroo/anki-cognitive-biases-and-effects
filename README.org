
An [[id:e4001525-d16c-4632-afc9-0813bf574b4b][Anki]] deck to memorize information about cognitive bias

* Plan
Due to my [[id:a3af9090-a8e6-4e7a-9d49-a26d9d220c97][Tech Terms]] Project I should already have the code to go from an org table to an Anki Deck

So where is going to be our data source?

- There is [[https://upload.wikimedia.org/wikipedia/commons/6/65/Cognitive_bias_codex_en.svg?ref=insanelyusefulwebsites&utm_source=pocket_mylist][this great svg file]]
- But [[https://en.wikipedia.org/wiki/List_of_cognitive_biases][this wikipedia list looks even better]]

I guess you can actually pull that second one into a buffer and then use [[https://github.com/AdamNiederer/elquery][elquery]] within [[id:3cf50942-d434-4726-b56b-7749839090d7][Emacs]]. 

Though actually maybe even you can do it with [[https://github.com/tree-sitter/tree-sitter-html][tree-sitter]]

* Playground

  First lets try to open up a buffer and load it with that html
  
  This is interesting, but it results in just the text of the page layed out visually, not html...which is a rather interesting ability
  
#+begin_src emacs-lisp
  (eww-browse-url "https://en.wikipedia.org/wiki/List_of_cognitive_biases")
  (html-mode)
  (rename-buffer "*Cognitive Biases*")
#+end_src


#+begin_src emacs-lisp :results silent
  (require 'request)
  (with-current-buffer (get-buffer-create "*Cognitive Bias*")
    (->> (request "https://en.wikipedia.org/wiki/List_of_cognitive_biases"
           :sync 't)
         request-response-data
         insert)
    (html-mode))
#+end_src

That's not bad, but tree-sitter just looks like stuff like this

#+begin_quote
        self_closing_tag:
          tag_name:
          attribute:
            attribute_name:
            quoted_attribute_value:
              attribute_value:
          attribute:
            attribute_name:
            quoted_attribute_value:
              attribute_value:
#+end_quote

That can still totally be filtered but surely something else is better

And looks like elquery would even skip that and just let us fetch a parsed three from a url

So how do we do this with that?
#+begin_src emacs-lisp
  (require 'elquery)
  (->> (elquery-read-buffer "*Cognitive Bias*")
       (elquery-$ "h3")
       (nth 15)
       elquery-full-text)
#+end_src

#+RESULTS:
: Availability heuristic[edit]

Ok so working off of html is going to suck. There's [[https://www.mediawiki.org/wiki/API:Get_the_contents_of_a_page][some apis available though]]

#+begin_src emacs-lisp :results silent
  (require 'request)
  
  (iter-defun gim/cognitive-bias-deck/parse ()
    "Parse the current buffer and generate tree of nodes. Returns an iterator."
    (while (not (eobp))
      (forward-line)))
  
  
  
  (with-current-buffer (get-buffer-create "*Cognitive Bias*")
    (erase-buffer)
    (mediawiki-mode)
    (let ((wikitext (->> (request "https://en.wikipedia.org/w/api.php?action=parse&page=List_of_cognitive_biases&prop=wikitext&formatversion=2&format=json"
                           :sync 't)
                         request-response-data
                         json-parse-string
                         (gethash "parse")
                         (gethash "wikitext"))))
      (insert wikitext)
      (beginning-of-buffer)
      (while (not (mediawiki-next-header))
        (message  "At header %s" (thing-at-point 'line))
        (let* ((header-title-point (point))
               (end-of-header-point (if (mediawiki-next-header)
                                        (point-max)
                                        (forward-line -1)
                                        (point)
                                        (mediawiki-prev-header))))
          (message "From %s to %s" header-title-point end-of-header-point)))))
  
  
  ;; (while (not (eobp))
  ;;   (when (looking-at-p "^\*")
  ;;     (message  (thing-at-point 'line)))
  ;;   (forward-line))))
#+end_src

#+begin_src emacs-lisp :results output :lexical yes
  (require 'request)
  
  (defvar gim/cognitive-bias-deck/list-of-false-positive-biases
    '("Misattribution of memory"
      "self-assessment"
      "Prospect theory"
      "Logical fallacy"
      "Extension neglect"
      "Other")
    "When parsing wikipedia for biases. These are false positives that will be filtered out of the results.")
  
  (defmacro gim/cognitive-bias-deck/parse/for-each-line (&rest other-clauses)
    "Move through each line remaining in a cl-loop. Any other cl-loop clauses are simply embedded. On each pass bind a variable line. If reached the end of buffer return nil"
    `(cl-loop for line = (thing-at-point 'line 't)
              until (eobp)
              finally return nil
              ,@other-clauses
              do (forward-line)))
  
  
  (defun gim/cognitive-bias-deck/parse/forward-to-next-header-3 ()
    (gim/cognitive-bias-deck/parse/for-each-line if (string-match "^===\\([^=]*\\)===" line)
                                                 return (cons 'category-name (s-trim (match-string-no-properties 1 line)))))
  
  (defun gim/cognitive-bias-deck/parse/forward-past-category-description ()
    (gim/cognitive-bias-deck/parse/for-each-line
     if (string-match "^\\w" line)
     return (cons 'category-description line)
     finally do (forward-line)))
  
  (iter-defun gim/cognitive-bias-deck/parse/forward-past-list ()
    (gim/cognitive-bias-deck/parse/for-each-line
     while (string-match "^\*\\(.+\\)" line)
     do (iter-yield `(line . ,line))
     finally do (forward-line)))
  
  ; TODO - This would be better as "to next list item or heading"
  (defun gim/cognitive-bias-deck/parse/forward-to-next-list-item ()
    (gim/cognitive-bias-deck/parse/for-each-line until (string-match "^\*" line)))
  
  
  (defun gim/cognitive-bias-deck/parse/parse-bias (line)
    (pcase-let ((`(line . ,text) line))
      (when (string-match (rx line-start
                              "*"
                              (zero-or-more space)
                              "[["
                              (group-n 1 (zero-or-more (not "]")))
                              "]]"
                              (zero-or-one ",")
                              (zero-or-more space)
                              (group-n 2 (one-or-more anything)))
                          text)
            `(bias . ((name . ,(match-string-no-properties 1 text))
                      (description . ,(match-string-no-properties 2 text)))))))
  
  
  (iter-defun gim/cognitive-bias-deck/parse ()
    "Parse the current buffer and generate tree of nodes. Returns an iterator."
    (cl-loop for category-name = (gim/cognitive-bias-deck/parse/forward-to-next-header-3)
             while category-name
             do (-let ((category-description (gim/cognitive-bias-deck/parse/forward-past-category-description)))
                  (gim/cognitive-bias-deck/parse/forward-to-next-list-item)
                  (iter-yield `(category . ((name . ,(cdr category-name))
                                            (description . ,(cdr category-description))
                                            (biases . ,(cl-loop for b iter-by (gim/cognitive-bias-deck/parse/forward-past-list)
                                                                collect (gim/cognitive-bias-deck/parse/parse-bias b)))))))))
  
  (iter-defun gim/cognitive-bias-deck/document-tree-to-bias-list (node)
    (pcase node
      (`())
      ((pred atom) (error "Called with atom parameter type %s" node))
      ;; I am not aware of a better way of testing for an iterator but checking for a 'closure car
      ((app car 'closure) (cl-loop for x iter-by node
                                   do (iter-yield-from (gim/cognitive-bias-deck/document-tree-to-bias-list x))))
      ((app car 'bias) (iter-yield (cdr node)))
      ;; TODO - I Do not understand why destructuring doesn't work here but it causes issues for iter-yield-from
      ((app car 'category) (-let ((attributes (cdr node)))
                             (iter-yield (list (assoc 'name attributes)
                                               (assoc 'description attributes)))
                             (when-let ((biases (alist-get 'biases attributes '())))
                                       (iter-yield-from (gim/cognitive-bias-deck/document-tree-to-bias-list biases)))))
      ((pred listp) (cl-loop for x in node
                             do (iter-yield-from (gim/cognitive-bias-deck/document-tree-to-bias-list x))))
      (_ (error "Called with unknown parameter type %s" node))))
  
  (iter-defun gim/cognitive-bias-deck/parse-buffer-to-bias-list ()
    (->> (gim/cognitive-bias-deck/parse)
         (gim/cognitive-bias-deck/document-tree-to-bias-list)
         iter-yield-from))
  
  
  (with-current-buffer (get-buffer-create "*Cognitive Bias*")
    (erase-buffer)
    (mediawiki-mode)
    (->> (request "https://en.wikipedia.org/w/api.php?action=parse&page=List_of_cognitive_biases&prop=wikitext&formatversion=2&format=json"
           :sync 't)
         request-response-data
         json-parse-string
         (gethash "parse")
         (gethash "wikitext")
         insert)
    (beginning-of-buffer)
  
    (iter-do (item (gim/cognitive-bias-deck/parse-buffer-to-bias-list))
      (pp item)))
#+end_src

#+RESULTS:


